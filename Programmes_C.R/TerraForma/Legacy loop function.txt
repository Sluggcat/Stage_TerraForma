  if (reading_request_phase) {  // Ask for reading
    //send a read command. we use this command instead of PH.send_cmd("R");
    //to let the library know to parse the reading
    get_temperature(tsensor, &Celsius, &Fahrenheit, &Kelvin);                               // Get the temp and perform conversions.
    get_pressure_depth(psensor, &Decibars, &Meters, &Feet, &Fathoms, &AtmP, &AbsPressure);  // Get the pressure and perform conversions.

    #if USE_ATLAS
      EC.send_read_with_temp_comp(Celsius);  // Get the conductivity with temperature compensation.
      PH.send_read_cmd();
      ORP.send_read_cmd();
      DO.send_read_cmd();
    #endif

    AS7341gainControl(as7341, myGAIN, RAW_color_readings);

    next_poll_time = millis() + response_delay;  //set when the response will arrive
    reading_request_phase = false;               //switch to the receiving phase
  }

  else {                                // Receiving phase
    if (millis() >= next_poll_time) {   //and its time to get the response
      #if USE_ATLAS
        float ec_val = receive_reading(EC);    //get the reading from the EC circuit
        float ph_val = receive_reading(PH);    //get the reading from the PH circuit
        float orp_val = receive_reading(ORP);  //get the reading from the ORP circuit
        float do_val = receive_reading(DO);    //get the reading from the DO circuit

        #if DEBUG_SERIALPRINT
          Serial.print("EC: ");
          Serial.println(ec_val);
          Serial.print("PH: ");
          Serial.println(ph_val);
          Serial.print("ORP: ");
          Serial.println(orp_val);
          Serial.print("DO: ");
          Serial.println(do_val);
        #endif
      #endif

    #if DEBUG_SERIALPRINT
      Serial.print("T°: ");
      Serial.print(Celsius);
      Serial.println(" °C");

      Serial.print("P: ");
      Serial.print(AbsPressure);
      Serial.println(" hPa\n===\n");
    #endif

    #if USE_BLE
      #if USE_BLYNK
        Blynk.virtualWrite(V0, Celsius);
        Blynk.virtualWrite(V1, AbsPressure);
        #if USE_ATLAS
          Blynk.virtualWrite(V2, EC.get_last_received_reading());
          Blynk.virtualWrite(V3, PH.get_last_received_reading());
          Blynk.virtualWrite(V4, ORP.get_last_received_reading());
          Blynk.virtualWrite(V5, DO.get_last_received_reading());
        #endif
      #endif
    #endif

    #if USE_OLED
      oled.clearDisplay();
      oled.setCursor(0, 0);

      for (int k = 0; k < 10; k++) {
        oled.print("F");
        oled.print(colorList[k] + 1);
        oled.print(" ");
        oled.println(RAW_color_readings[colorList[k]]);
      }
      oled.display();
    #endif

      nbSamples = 0;  // Zeroes the AS7341 number of samples and prepare for next acquisition cycle.
      for (int j = 0; j < 10; j++) {
        average_color_readings[colorList[j]] = 0;
      }

    #if USE_BLE
      if (ble.available() > 0) {                                                                      //If a connection is made...
        CommandMode(ble, as7341, myGAIN, datafile, recentfile, integrationTime, rtc, AtmP, AirTemp);  //...continue to collect data and wait for several command options from user.
      }
    #endif
      // Save files here

      //Send data to Boopy here
      float data[14] = {-1, -1, -1, -1, Celsius, AbsPressure,
              RAW_color_readings[colorList[0]], RAW_color_readings[colorList[1]], RAW_color_readings[colorList[2]], RAW_color_readings[colorList[3]],
              RAW_color_readings[colorList[4]], RAW_color_readings[colorList[5]], RAW_color_readings[colorList[6]], RAW_color_readings[colorList[7]]
              };
      #if USE_ATLAS
        data[0] = ec_val;
        data[1] = ph_val;
        data[2] = orp_val;
        data[3] = do_val;
      #endif
      Terra_sender.sendData(data);
      reading_request_phase = true;  //switch back to asking for readings
    }
  }

  // Non-blocking reading for AS7341. Done in the main loop to increase sample numbers and do some averaging.
  bool timeOutFlag = yourTimeOutCheck();

  if (as7341.checkReadingProgress() || timeOutFlag) {
    if (timeOutFlag) {}

    as7341.getAllChannels(RAW_color_readings);
    nbSamples++;

    // Here we do the averaging based on the number of samples already acquired. Average calculation is based on Basic
    // counts instead of RAW counts because of the AGC.
    for (int j = 0; j < 10; j++) {
      average_color_readings[colorList[j]] = (average_color_readings[colorList[j]] + as7341.toBasicCounts(RAW_color_readings[colorList[j]])) / nbSamples;
    }
    as7341.startReading();
  }

  #if USE_BLE
    #if USE_BLYNK
      Blynk.run();
    #endif
  #endif